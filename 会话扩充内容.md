## 会话安全性
### 会话劫持和防御
1.会话劫持：原名Session Hijacking，是一种网络攻击，攻击者通过各种手段获取用户会话的凭证，从而伪装成用户，访问用户的账户和资源。这种攻击通常发生在用户登录并保持会话状态的情况下，攻击者可以利用这些信息进行身份欺骗，窃取敏感信息或执行其他恶意操作。  
![TCP会话劫持实验](https://img-blog.csdnimg.cn/76bfe86b2f614e4c93f27742bba3cf71.png)  
2.会话防御：在网络安全领域中保护用户会话安全的一系列措施和技术。它旨在防止未经授权的访问、会话劫持和用户会话被篡改，确保用户的会话数据安全。  
### 跨站脚本攻击（xss）和防御  
1.XSS（Cross Site Script）跨站式脚本攻击，即用户在能够提交内容的网页的任何地方，提交了恶意脚本代码，使得WEB服务器收到用户内容并存储后，下一次有其他用户访问网页时，浏览器会自动解析提交的脚本而造成恶意的攻击。  
2.防御策略：  
①对用户输入做好过滤和转义处理，避免被直接执行作为脚本代码。开发者可以使用一些现成的库和框架来实现数据过滤和转义，例如OWASP ESAPI、JQuery等。  
②在请求中包含HTTPOnly标记的cookie，避免JavaScript脚本获取Cookie值。  
③配置CSP（Content-Security-Policy）头部，限制页面资源的加载和执行，减少XSS攻击的可能性。  
④使用低特权账号和权限分离策略，避免敏感操作的恶意执行和篡改页面内容。  
⑤及时更新补丁和升级软件版本，以消除可能存在的安全漏洞。  
⑥对于发生XSS攻击的网站，及时清除和恢复受影响的数据，同时加强监控和日志审计，快速发现异常情况并进行处理。  
### 跨站请求伪造（CSRF）和防御  
1.跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。  
2.防御策略：CSRF令牌和检查请求来源。
***  
## 分布式会话管理  
### 分布式环境下的会话同步问题  
分布式系统中，用户请求可能被分配给不同的服务器，导致会话状态在不同服务器间不能共享。  
![Session同步问题](https://i-blog.csdnimg.cn/blog_migrate/587f4b70ee993eb9605aa8e1b83fe92e.png)
###  Session集群解决方案
①session复制：服务器将自己的session数据传送给其他服务器，使得每个服务器都拥有全量的数据。  
②客户端存储：用户的信息不再保存在服务器中，而是保存在客户端(浏览器)中。  
③hash一致性：nginx负载均衡的时候采用ip-hash策略，这样同一个客户端每次的请求都会被同一个服务器处理。
④统一存储：jsessionid这个cookie默认是系统域名。当我们分拆服务，不同域名部署的时候，我们可以使用如下解决方案。
### 使用Redis等缓冲技术实现分布式会话  
    环境准备  
    确保安装了Redis并在运行中。  
    创建一个Spring Boot项目，并在pom.xml中添加Redis相关依赖。
    <dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-data-redis</artifactId>  
    </dependency>  
    <dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-web</artifactId>  
    </dependency>  
    <dependency>  
    <groupId>org.springframework.session</groupId>  
    <artifactId>spring-session-data-redis</artifactId>  
    </dependency>  
    配置Redis
    在application.properties中配置Redis连接信息。
    spring.redis.host=localhost  
    spring.redis.port=6379  
    spring.session.store-type=redis  
    创建会话管理器
    可以使用Spring Session来简化与Redis的集成。以下是示例代码：
    import org.springframework.context.annotation.Bean;  
    import org.springframework.context.annotation.Configuration;  
    import org.springframework.data.redis.connection.RedisConnectionFactory;  
    import org.springframework.data.redis.core.RedisTemplate;  
    import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
    @Configuration  
    @EnableRedisHttpSession // 启用Redis HTTP会话  
    public class RedisConfig {
    @Bean  
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {  
        RedisTemplate<String, Object> template = new RedisTemplate<>();  
        template.setConnectionFactory(connectionFactory);  
        return template;  
    }  
    }   
    创建控制器
    下面是一个简单的控制器示例，展示如何使用会话存储用户数据：
    import org.springframework.session.data.redis.RedisOperationsSessionRepository;  
    import org.springframework.web.bind.annotation.*;
    import javax.servlet.http.HttpSession;
    @RestController  
    @RequestMapping("/session")  
    public class SessionController {
    @PostMapping("/set")  
    public String setSession(HttpSession session, @RequestParam String name) {  
        session.setAttribute("username", name);  
        return "Session set for user: " + name;  
    }
    @GetMapping("/get")  
    public String getSession(HttpSession session) {  
        String username = (String) session.getAttribute("username");  
        return username != null ? "Hello, " + username : "No session found";  
    }  
    }
***
## 会话状态的序列化和反序列化
### 会话状态的序列化和反序列化  
1.序列化：将当前会话的数据结构或对象转换为字节流（如JSON、XML或二进制格式），以便在网络传输或保存到磁盘上。这通常用于客户端和服务端之间的数据交换，或者是服务重启时保持用户状态。  
2.反序列化：从字节流或其他存储形式还原回原始的对象或数据结构，使得后续处理能够继续使用之前会话的状态。例如，当服务器接收到序列化的请求后，它会反序列化数据并执行相应的业务逻辑。  
### 为什么需要序列化会话状态  
序列化会话状态可以在服务器重启、分布式环境中共享会话或者在网络间传输数据时保持会话的持久性。
### Java对象序列化  
JAVA提供了对象序列化机制可以将JAVA对象转换为字节流以便存储或者在网络间传输数据时保持会话的持久性。
### 自定义序列化策略  
开发者可以控制哪些字段需要序列化，哪些字段可以忽略，甚至可以自定义序列化和反序列化过程。  

    class CustomUser implements Serializable {  
    private String username;  
    private transient String password; // 不序列化密码
    public CustomUser(String username, String password) {  
        this.username = username;  
        this.password = password;  
    }
    private void writeObject(ObjectOutputStream oos) throws IOException {  
        oos.defaultWriteObject(); // 默认序列化  
        // 额外逻辑可以在这里添加  
    }
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {  
        ois.defaultReadObject(); // 默认反序列化  
        // 额外逻辑可以在这里添加  
    }  
    }  
